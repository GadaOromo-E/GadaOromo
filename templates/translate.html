<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Translator | Gada Oromo Dictionary</title>
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>

<div class="container">

  <div class="topbar">
    <div class="title-row">
      <div>
        <h2 style="margin:0;">ğŸŒ Oromo â†” English Translator</h2>
        <div class="subtle">
          {% if direction == "om_en" %}Detected/Selected: Oromo â†’ English
          {% elif direction == "en_om" %}Detected/Selected: English â†’ Oromo
          {% else %}Detected/Selected: Auto{% endif %}
        </div>
      </div>
      <a class="btn danger" href="/">â¬… Home</a>
    </div>
  </div>

  <div class="card">
    <form method="POST" id="translateForm">
      <div class="row">
        <select name="direction" id="directionSelect">
          <option value="auto" {% if direction == "auto" %}selected{% endif %}>Auto Detect</option>
          <option value="om_en" {% if direction == "om_en" %}selected{% endif %}>Oromo â†’ English</option>
          <option value="en_om" {% if direction == "en_om" %}selected{% endif %}>English â†’ Oromo</option>
        </select>

        <button type="button" onclick="startVoice()">ğŸ¤ Speak</button>
      </div>

      <textarea name="text" id="textInput" placeholder="Type word or sentence..." required oninput="autoGrow(this)">{{ text or "" }}</textarea>

      <div class="bottom-bar">
        <div class="bottom-actions">
          <button type="submit">Translate</button>
          <a class="btn" href="javascript:void(0)" onclick="speakInput()">ğŸ”Š Speak Input</a>
        </div>
      </div>

      <div class="small-actions">
        <button type="button" class="btn" onclick="clearInput()">ğŸ§¹ Clear</button>
        <button type="button" class="btn" onclick="swapDirection()">ğŸ” Swap</button>
      </div>
    </form>

    {% if result %}
      <div class="result-box">
        <strong>Result:</strong> <span id="resultText">{{ result }}</span>
      </div>

      <div class="small-actions">
        <button type="button" class="btn" onclick="speakResult()">ğŸ”Š Speak Result</button>
        <button type="button" class="btn" onclick="copyResult()">ğŸ“‹ Copy Result</button>
      </div>
    {% else %}
      <div class="result-box" style="opacity:0.85;">Result will appear hereâ€¦</div>
    {% endif %}

    <!-- ===== Community Audio (approved) ===== -->
    {% if audio %}
      <div style="margin-top:14px;">
        <h2>ğŸ§ Community Pronunciation</h2>

        {% if audio.oromo %}
          <div class="subtle">Oromo audio</div>
          <audio controls>
            <source src="{{ url_for('static', filename=audio.oromo) }}">
          </audio>
        {% endif %}

        {% if audio.english %}
          <div class="subtle" style="margin-top:10px;">English audio</div>
          <audio controls>
            <source src="{{ url_for('static', filename=audio.english) }}">
          </audio>
        {% endif %}

        {% if not audio.oromo and not audio.english %}
          <div class="muted">No approved audio yet.</div>
        {% endif %}
      </div>
    {% endif %}

    <!-- ===== NEW: Inline Recording (only when exact match exists) ===== -->
    {% if matched %}
      <div style="margin-top:14px;">
        <h2>ğŸ™ Help the community</h2>
        <div class="muted" style="margin-top:6px;">
          Record Oromo pronunciation here. It becomes public after admin approval.
        </div>

        {# Hide mic if Oromo audio already approved for this matched entry #}
        {% set is_word = (matched.type == "word") %}
        {% set is_phrase = (matched.type == "phrase") %}

        {% set has_approved_oromo =
          (is_word and (matched.id in approved_oromo_audio_word_ids)) or
          (is_phrase and (matched.id in approved_oromo_audio_phrase_ids))
        %}

        {% if not has_approved_oromo %}
          <div class="small-actions" style="margin-top:10px;">
            <button
              type="button"
              class="btn primary"
              data-record-btn
              data-entry-type="{{ matched.type }}"
              data-entry-id="{{ matched.id }}"
              data-lang="oromo"
              title="Record Oromo pronunciation"
            >ğŸ™ Record Oromo</button>

            <button
              type="button"
              class="btn"
              data-stop-btn
              style="display:none;"
            >â¹ Stop</button>
          </div>

          <audio data-preview-audio controls style="width:100%; display:none; margin-top:10px;"></audio>

          <div data-trim-box class="trim" style="display:none; margin-top:10px;">
            <div class="subtle" style="margin-bottom:6px;">Optional: trim before submitting</div>
            <label>Start (sec)
              <input data-trim-start type="number" min="0" step="0.1" value="0">
            </label>
            <label style="margin-left:8px;">End (sec)
              <input data-trim-end type="number" min="0" step="0.1" value="0">
            </label>
            <button type="button" class="btn" data-apply-trim>âœ‚ï¸ Apply Trim</button>
          </div>

          <div class="small-actions" style="margin-top:10px;">
            <button type="button" class="btn primary" data-submit-btn style="display:none;">âœ… Submit</button>
            <button type="button" class="btn" data-rerecord-btn style="display:none;">ğŸ” Re-record</button>
          </div>

          <div class="muted" data-status-for="{{ matched.type }}_{{ matched.id }}" style="margin-top:8px;"></div>
        {% else %}
          <div class="muted" style="margin-top:10px;">âœ… Oromo audio already approved for this {{ matched.type }}.</div>
        {% endif %}

        <!-- Keep your old manual upload links too (optional) -->
        <div class="small-actions" style="margin-top:10px;">
          <a class="btn" href="/upload_audio/{{ matched.type }}/{{ matched.id }}/oromo">Upload Oromo audio (file)</a>
          <a class="btn" href="/upload_audio/{{ matched.type }}/{{ matched.id }}/english">Upload English audio (file)</a>
        </div>
      </div>
    {% endif %}

    {% if suggestions %}
      <div style="margin-top:14px;">
        <h2>Did you meanâ€¦</h2>

        {% if suggestions.closest and suggestions.closest|length > 0 %}
          <div class="subtle">Closest matches</div>
          <div class="chips">
            {% for s in suggestions.closest %}
              <span class="chip" onclick="useSuggestion('{{ s|e }}')">{{ s }}</span>
            {% endfor %}
          </div>
        {% endif %}

        {% if suggestions.prefix and suggestions.prefix|length > 0 %}
          <div class="subtle" style="margin-top:10px;">Starts with</div>
          <div class="chips">
            {% for s in suggestions.prefix %}
              <span class="chip" onclick="useSuggestion('{{ s|e }}')">{{ s }}</span>
            {% endfor %}
          </div>
        {% endif %}

        {% if suggestions.partial and suggestions.partial|length > 0 %}
          <div class="subtle" style="margin-top:10px;">Contains</div>
          <div class="chips">
            {% for s in suggestions.partial %}
              <span class="chip" onclick="useSuggestion('{{ s|e }}')">{{ s }}</span>
            {% endfor %}
          </div>
        {% endif %}
      </div>
    {% endif %}

    {% if trending %}
      <div style="margin-top:14px;">
        <h2>ğŸ”¥ Trending</h2>
        <div class="chips">
          {% for row in trending %}
            <span class="chip" onclick="useSuggestion('{{ row[0]|e }}')">{{ row[0] }}</span>
          {% endfor %}
        </div>
      </div>
    {% endif %}

  </div>
</div>

<script>
function autoGrow(el){ el.style.height="auto"; el.style.height=(el.scrollHeight)+"px"; }
window.addEventListener("load", ()=>{ const ta=document.getElementById("textInput"); if(ta) autoGrow(ta); });

function useSuggestion(text){ const ta=document.getElementById("textInput"); ta.value=text; autoGrow(ta); document.getElementById("translateForm").submit(); }
function clearInput(){ const ta=document.getElementById("textInput"); ta.value=""; autoGrow(ta); ta.focus(); }
function swapDirection(){
  const sel=document.getElementById("directionSelect");
  if(sel.value==="om_en") sel.value="en_om";
  else if(sel.value==="en_om") sel.value="om_en";
  else sel.value="en_om";
}
function copyResult(){
  const el=document.getElementById("resultText");
  const txt=el?el.innerText:"";
  if(!txt) return alert("Nothing to copy.");
  navigator.clipboard.writeText(txt).then(()=>alert("Copied!")).catch(()=>alert("Copy failed."));
}

/* Voice output */
let cachedVoices = [];
function loadVoices(){ cachedVoices = window.speechSynthesis ? window.speechSynthesis.getVoices() : []; }
if ('speechSynthesis' in window) {
  loadVoices();
  window.speechSynthesis.onvoiceschanged = loadVoices;
}
function pickBestVoice(langCode){
  if(!cachedVoices || cachedVoices.length===0) return null;
  const lc=(langCode||"").toLowerCase();
  let v=cachedVoices.find(x => (x.lang||"").toLowerCase()===lc);
  if(v) return v;
  const base=lc.split("-")[0];
  v=cachedVoices.find(x => (x.lang||"").toLowerCase().startsWith(base));
  if(v) return v;
  v=cachedVoices.find(x => (x.lang||"").toLowerCase().startsWith("en"));
  return v || null;
}

function speakText(text, langCode){
  if(!('speechSynthesis' in window)) return alert("Speech is not supported in this browser.");
  if(!text || !text.trim()) return alert("Nothing to speak.");
  const u=new SpeechSynthesisUtterance(text);
  const best=pickBestVoice(langCode);
  if(best){ u.voice=best; u.lang=best.lang; } else { u.lang=langCode; }
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(u);
}

function speakInput(){
  const txt=document.getElementById("textInput").value;
  const dir=document.getElementById("directionSelect").value;
  const lang=(dir==="om_en") ? "om-ET" : "en-US";
  speakText(txt, lang);
}
function speakResult(){
  const el=document.getElementById("resultText");
  const txt=el?el.innerText:"";
  const dir=document.getElementById("directionSelect").value;
  const lang=(dir==="om_en") ? "en-US" : "om-ET";
  speakText(txt, lang);
}

/* Speech-to-text */
function startVoice(){
  const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
  if(!SpeechRecognition) return alert("Voice input not supported. Use Chrome on PC/Android.");
  const recognition=new SpeechRecognition();
  const dir=document.getElementById("directionSelect").value;
  recognition.lang=(dir==="om_en") ? "om-ET" : "en-US";
  recognition.interimResults=false;

  recognition.onresult=function(event){
    const text=event.results[0][0].transcript;
    const ta=document.getElementById("textInput");
    ta.value=text; autoGrow(ta);
  };
  recognition.onerror=function(e){ alert("Voice input error: " + e.error); };
  recognition.start();
}

/* =========================
   Inline Recording + Preview + Trim + Submit (matched entry)
   Uses POST /api/submit-audio
   ========================= */

let activeRecorder = null;
let activeChunks = [];
let activeStream = null;
let activeTarget = null;

function pickMimeType(){
  const mimeChoices = [
    "audio/webm;codecs=opus",
    "audio/webm",
    "audio/ogg;codecs=opus",
    "audio/ogg"
  ];
  for (const m of mimeChoices) {
    if (window.MediaRecorder && MediaRecorder.isTypeSupported(m)) return m;
  }
  return "";
}

function getStatusEl(entryType, entryId){
  return document.querySelector(`[data-status-for="${entryType}_${entryId}"]`);
}

async function startRecording(target){
  if (!navigator.mediaDevices || !window.MediaRecorder) {
    alert("Recording not supported. Use Chrome/Edge on PC/Android.");
    return;
  }

  if (activeRecorder && activeRecorder.state !== "inactive") {
    try { activeRecorder.stop(); } catch(e) {}
  }

  try {
    activeStream = await navigator.mediaDevices.getUserMedia({ audio: true });
  } catch (e) {
    alert("Microphone permission denied.");
    return;
  }

  const mimeType = pickMimeType();
  activeChunks = [];
  activeTarget = target;

  activeRecorder = new MediaRecorder(activeStream, mimeType ? { mimeType } : undefined);

  activeRecorder.ondataavailable = (ev) => {
    if (ev.data && ev.data.size > 0) activeChunks.push(ev.data);
  };

  activeRecorder.onstop = async () => {
    if (activeStream) {
      activeStream.getTracks().forEach(t => t.stop());
      activeStream = null;
    }

    const recordedBlob = new Blob(activeChunks, { type: activeRecorder.mimeType || "audio/webm" });
    activeChunks = [];

    setupEditorUI(target, recordedBlob);
  };

  // UI changes
  const st = getStatusEl(target.entryType, target.entryId);
  if (st) st.textContent = "Recordingâ€¦ speak Oromo clearly";

  target.recordBtn.style.display = "none";
  target.stopBtn.style.display = "";

  activeRecorder.start();
}

function stopRecording(){
  if (activeRecorder && activeRecorder.state !== "inactive") {
    activeRecorder.stop();
  }
}

function setupEditorUI(target, recordedBlob){
  const st = getStatusEl(target.entryType, target.entryId);

  target.stopBtn.style.display = "none";

  let finalBlob = recordedBlob;

  target.previewAudio.src = URL.createObjectURL(recordedBlob);
  target.previewAudio.style.display = "";

  target.previewAudio.onloadedmetadata = () => {
    const dur = target.previewAudio.duration || 0;
    target.trimStart.value = 0;
    target.trimEnd.value = dur.toFixed(2);
    target.trimBox.style.display = "";
    target.submitBtn.style.display = "";
    target.rerecordBtn.style.display = "";
    if (st) st.textContent = `Recorded ${dur.toFixed(2)}s. Trim if needed, then submit.`;
  };

  target.rerecordBtn.onclick = () => {
    target.previewAudio.pause();
    target.previewAudio.style.display = "none";
    target.trimBox.style.display = "none";
    target.submitBtn.style.display = "none";
    target.rerecordBtn.style.display = "none";
    target.recordBtn.style.display = "";
    if (st) st.textContent = "Ready to re-record.";
  };

  target.applyTrimBtn.onclick = async () => {
    const s = parseFloat(target.trimStart.value || "0");
    const e = parseFloat(target.trimEnd.value || "0");
    if (!(e > s)) {
      if (st) st.textContent = "Trim error: End must be greater than Start.";
      return;
    }

    if (st) st.textContent = "Applying trimâ€¦";

    try {
      finalBlob = await trimBlobToWav(recordedBlob, s, e);
      target.previewAudio.src = URL.createObjectURL(finalBlob);
      if (st) st.textContent = `Trimmed: ${s.toFixed(2)}s â†’ ${e.toFixed(2)}s. Preview then submit.`;
    } catch (err) {
      console.error(err);
      if (st) st.textContent = "Trim failed. You can still submit without trimming.";
      finalBlob = recordedBlob;
    }
  };

  target.submitBtn.onclick = async () => {
    target.submitBtn.disabled = true;
    target.rerecordBtn.disabled = true;
    if (st) st.textContent = "â³ Uploading...";

    const ok = await uploadAudio(target.entryType, target.entryId, target.lang, finalBlob).catch(() => false);

    if (ok) {
      if (st) st.textContent = "âœ… Submitted (pending admin approval)";
      target.trimBox.style.display = "none";
      target.submitBtn.style.display = "none";
      target.rerecordBtn.style.display = "none";
      // keep preview visible (optional). If you want to hide it, uncomment:
      // target.previewAudio.style.display = "none";
    } else {
      if (st) st.textContent = "âŒ Upload failed";
      target.submitBtn.disabled = false;
      target.rerecordBtn.disabled = false;
    }
  };
}

async function uploadAudio(entryType, entryId, lang, blob){
  const fd = new FormData();

  let ext = "webm";
  const bt = (blob.type || "").toLowerCase();
  if (bt.includes("wav")) ext = "wav";
  else if (bt.includes("ogg")) ext = "ogg";

  fd.append("entry_type", entryType);
  fd.append("entry_id", String(entryId));
  fd.append("lang", lang);
  fd.append("audio", new File([blob], `${lang}_${entryType}_${entryId}.${ext}`, { type: blob.type || "application/octet-stream" }));

  const resp = await fetch(`/api/submit-audio`, { method: "POST", body: fd });
  if (!resp.ok) return false;
  const data = await resp.json().catch(() => null);
  return !!(data && data.ok);
}

async function trimBlobToWav(blob, startSec, endSec){
  const arrayBuffer = await blob.arrayBuffer();
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  const audioCtx = new AudioCtx();
  const decoded = await audioCtx.decodeAudioData(arrayBuffer);

  const sr = decoded.sampleRate;
  const startSample = Math.max(0, Math.floor(startSec * sr));
  const endSample = Math.min(decoded.length, Math.floor(endSec * sr));
  const frameCount = endSample - startSample;
  if (frameCount <= 0) throw new Error("Trim selection too small");

  const trimmed = audioCtx.createBuffer(decoded.numberOfChannels, frameCount, sr);
  for (let ch = 0; ch < decoded.numberOfChannels; ch++) {
    const slice = decoded.getChannelData(ch).slice(startSample, endSample);
    trimmed.copyToChannel(slice, ch, 0);
  }

  return audioBufferToWavBlob(trimmed);
}

function audioBufferToWavBlob(buffer) {
  const numChannels = buffer.numberOfChannels;
  const sampleRate = buffer.sampleRate;
  const bitDepth = 16;
  const bytesPerSample = bitDepth / 8;

  const blockAlign = numChannels * bytesPerSample;
  const byteRate = sampleRate * blockAlign;
  const dataSize = buffer.length * blockAlign;
  const bufferSize = 44 + dataSize;

  const ab = new ArrayBuffer(bufferSize);
  const view = new DataView(ab);

  writeString(view, 0, "RIFF");
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, "WAVE");
  writeString(view, 12, "fmt ");
  view.setUint32(16, 16, true);
  view.setUint16(20, 1, true);
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sampleRate, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitDepth, true);
  writeString(view, 36, "data");
  view.setUint32(40, dataSize, true);

  let offset = 44;
  const channelData = [];
  for (let ch = 0; ch < numChannels; ch++) channelData.push(buffer.getChannelData(ch));

  for (let i = 0; i < buffer.length; i++) {
    for (let ch = 0; ch < numChannels; ch++) {
      let sample = Math.max(-1, Math.min(1, channelData[ch][i]));
      sample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
      view.setInt16(offset, sample, true);
      offset += 2;
    }
  }

  return new Blob([ab], { type: "audio/wav" });
}

function writeString(view, offset, str) {
  for (let i = 0; i < str.length; i++) view.setUint8(offset + i, str.charCodeAt(i));
}

/* Hook up buttons if present */
document.addEventListener("click", function(e){
  const stopBtn = e.target && e.target.closest && e.target.closest("[data-stop-btn]");
  if (stopBtn) { stopRecording(); return; }

  const recordBtn = e.target && e.target.closest && e.target.closest("[data-record-btn]");
  if (!recordBtn) return;

  const entryType = recordBtn.getAttribute("data-entry-type") || "word";
  const entryId = parseInt(recordBtn.getAttribute("data-entry-id") || "0", 10);
  const lang = recordBtn.getAttribute("data-lang") || "oromo";

  const card = recordBtn.closest(".card");
  const previewAudio = card.querySelector("[data-preview-audio]");
  const trimBox = card.querySelector("[data-trim-box]");
  const trimStart = card.querySelector("[data-trim-start]");
  const trimEnd = card.querySelector("[data-trim-end]");
  const applyTrimBtn = card.querySelector("[data-apply-trim]");
  const submitBtn = card.querySelector("[data-submit-btn]");
  const rerecordBtn = card.querySelector("[data-rerecord-btn]");
  const stop = card.querySelector("[data-stop-btn]");

  startRecording({
    entryType,
    entryId,
    lang,
    recordBtn,
    stopBtn: stop,
    previewAudio,
    trimBox,
    trimStart,
    trimEnd,
    applyTrimBtn,
    submitBtn,
    rerecordBtn
  });
});
</script>

</body>
</html>





